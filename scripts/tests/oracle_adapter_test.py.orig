#!/usr/bin/env python3
"""Oracle adapter end-to-end test script.

Validates both offline and online (if aiohttp available) operation of oracle adapters:
1. Imports modules dynamically (graceful handling of missing dependencies)
2. Validates structure of returned data in both modes
3. Tests metrics collection and rate limiting
4. Tests integration with orchestrator

Usage:
  python oracle_adapter_test.py [--offline] [--install-deps]

Options:
  --offline      Force offline mode (default: auto-detect aiohttp)
  --install-deps Attempt to install aiohttp if missing
"""
import os
import sys
import time
import json
import asyncio
import argparse
import importlib.util
from pathlib import Path
from typing import Dict, List, Any, Optional

# Configure paths
PROJECT_ROOT = Path(__file__).parent.parent.parent
SCRIPTS_DIR = PROJECT_ROOT / "scripts"
sys.path.append(str(SCRIPTS_DIR))

# Parse arguments
parser = argparse.ArgumentParser(description="Test oracle adapters and orchestrator.")
parser.add_argument("--offline", action="store_true", help="Force offline mode")
parser.add_argument("--install-deps", action="store_true", help="Install aiohttp if missing")
args = parser.parse_args()

# Try to import or install aiohttp if requested
aiohttp_installed = False
if not args.offline and args.install_deps:
    try:
        import subprocess
        print("Installing aiohttp...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", "aiohttp", "--quiet"])
        print("aiohttp installed successfully")
        aiohttp_installed = True
    except Exception as e:
        print(f"Failed to install aiohttp: {e}")

# Check for aiohttp
if not args.offline and not aiohttp_installed:
    try:
        import aiohttp
        aiohttp_installed = True
    except ImportError:
        print("aiohttp not available - running in offline mode")

# Set environment based on detection
if args.offline or not aiohttp_installed:
    os.environ["OFFLINE"] = "1"
    print("Running in OFFLINE mode (using placeholders)")
else:
    os.environ.pop("OFFLINE", None)
    print("Running in ONLINE mode (using real adapters)")

# Import modules dynamically
sources_spec = importlib.util.spec_from_file_location(
    "oracle_sources", SCRIPTS_DIR / "oracle_sources.py"
)
orchestrator_spec = importlib.util.spec_from_file_location(
    "oracle_orchestrator", SCRIPTS_DIR / "oracle_orchestrator.py"
)

sources_module = importlib.util.module_from_spec(sources_spec)
orchestrator_module = importlib.util.module_from_spec(orchestrator_spec)

sources_spec.loader.exec_module(sources_module)
orchestrator_spec.loader.exec_module(orchestrator_module)

# Extract classes and functions
fetch_prices = sources_module.fetch_prices
get_source_metrics = sources_module.get_source_metrics
OracleConfig = orchestrator_module.OracleConfig
OracleOrchestrator = orchestrator_module.OracleOrchestrator

PAIRS = [
    ("BTC", "USD"),
    ("STX", "USD")
]

ADAPTERS = ["coingecko", "binance", "kraken"]

# Test functions
async def test_adapter_structure() -> bool:
    """Test adapter structure (shape, types) in both offline and online modes."""
    success = True
    
    # First check all adapters individually
    for source in ADAPTERS:
        for base, quote in PAIRS:
            try:
                adapter_fn = getattr(sources_module, source, None)
                if not adapter_fn:
                    print(f"Warning: {source} adapter function not found")
                    continue
                    
                result = await adapter_fn(base, quote)
                
                if not result and os.getenv("OFFLINE") == "1":
                    print(f"✓ {source}({base}/{quote}) correctly returned empty result in offline mode")
                    continue
                    
                if not result and os.getenv("OFFLINE") != "1":
                    print(f"✗ {source}({base}/{quote}) returned empty result in online mode")
                    success = False
                    continue
                    
                for entry in result:
                    # Validate fields and types
                    if not isinstance(entry.get("source"), str):
                        print(f"✗ {source}({base}/{quote}) missing source string")
                        success = False
                    
                    price = entry.get("price")
                    if not isinstance(price, int):
                        print(f"✗ {source}({base}/{quote}) price not int: {price}")
                        success = False
                    elif price <= 0:
                        print(f"✗ {source}({base}/{quote}) invalid price: {price}")
                        success = False
                        
                    timestamp = entry.get("timestamp")
                    if not isinstance(timestamp, int):
                        print(f"✗ {source}({base}/{quote}) timestamp not int: {timestamp}")
                        success = False
                    elif timestamp <= 0:
                        print(f"✗ {source}({base}/{quote}) invalid timestamp: {timestamp}")
                        success = False
                        
                if result:
                    print(f"✓ {source}({base}/{quote}) returned valid result")
            except Exception as e:
                print(f"✗ {source}({base}/{quote}) error: {e}")
                success = False
                
    # Now test fetch_prices combined function
    for base, quote in PAIRS:
        try:
            result = await fetch_prices(base, quote, ADAPTERS)
            
            if not result and os.getenv("OFFLINE") == "1":
                print(f"✓ fetch_prices({base}/{quote}) correctly returned empty result in offline mode")
                continue
                
            if not result and os.getenv("OFFLINE") != "1":
                print(f"✗ fetch_prices({base}/{quote}) returned empty result in online mode")
                success = False
                continue
                
            print(f"✓ fetch_prices({base}/{quote}) returned {len(result)} results")
        except Exception as e:
            print(f"✗ fetch_prices({base}/{quote}) error: {e}")
            success = False
            
    return success

async def test_metrics_collection() -> bool:
    """Test metrics collection."""
    success = True
    
    # Clear metrics between tests
    sources_module._SOURCE_METRICS = {}
    
    # Call adapters to generate metrics
    for base, quote in PAIRS:
        await fetch_prices(base, quote, ADAPTERS)
        
    # Get metrics
    metrics = get_source_metrics()
    
    if os.getenv("OFFLINE") == "1":
        # In offline mode, no metrics should be recorded
        if metrics:
            print(f"✗ Metrics collected in offline mode: {metrics}")
            success = False
        else:
            print("✓ No metrics collected in offline mode (as expected)")
    else:
        # In online mode, metrics should be recorded for each source
        if not metrics:
            print("✗ No metrics collected in online mode")
            success = False
        else:
            print(f"✓ Collected metrics for {len(metrics)} sources")
            for source, data in metrics.items():
                print(f"  - {source}: {data['ok']} ok, {data['err']} errors, {data.get('last_latency_ms')}ms")
                
    return success

async def test_orchestrator_integration() -> bool:
    """Test integration with orchestrator."""
    success = True
    
    # Configure orchestrator with offline or online mode
    config = OracleConfig()
    if os.getenv("OFFLINE") == "1":
        config.offline = True
        print("Testing orchestrator in offline mode...")
    else:
        config.offline = False
        print("Testing orchestrator in online mode...")
        
    config.external_sources = ADAPTERS
    
    try:
        orchestrator = OracleOrchestrator(config)
        await orchestrator.initialize()
        
        # Test orchestrator's price fetching and aggregation
        for pair_key, pair in orchestrator.trading_pairs.items():
            prices = await orchestrator._fetch_external_prices(pair.base, pair.quote)
            
            if not prices:
                if os.getenv("OFFLINE") != "1":
                    print(f"✗ No prices returned for {pair_key} in online mode")
                    success = False
                else:
                    print(f"✓ Orchestrator correctly used placeholder prices for {pair_key} in offline mode")
            else:
                # Check if we have prices
                print(f"✓ Orchestrator fetched {len(prices)} prices for {pair_key}")
                for p in prices:
                    print(f"  - {p['source']}: {p['price']}")
                
            # Test aggregation function
            if prices:
                median = await orchestrator._select_oracle_price(prices, None)
                if median > 0:
                    print(f"✓ Calculated trimmed-mean for {pair_key}: {median}")
                else:
                    print(f"✗ Invalid trimmed-mean for {pair_key}: {median}")
                    success = False
                
    except Exception as e:
        print(f"✗ Orchestrator integration error: {e}")
        success = False
        
    return success

async def main() -> int:
    """Main test function."""
    print("==== Oracle Adapter Test Suite ====")
    print(f"Mode: {'OFFLINE' if os.getenv('OFFLINE') == '1' else 'ONLINE'}")
    print()
    
    structure_ok = await test_adapter_structure()
    print()
    
    metrics_ok = await test_metrics_collection()
    print()
    
    orchestrator_ok = await test_orchestrator_integration()
    print()
    
    print("==== Test Summary ====")
    print(f"Adapter Structure: {'✓ PASS' if structure_ok else '✗ FAIL'}")
    print(f"Metrics Collection: {'✓ PASS' if metrics_ok else '✗ FAIL'}")
    print(f"Orchestrator Integration: {'✓ PASS' if orchestrator_ok else '✗ FAIL'}")
    print()
    
    overall = structure_ok and metrics_ok and orchestrator_ok
    print(f"Overall: {'✓ PASS' if overall else '✗ FAIL'}")
    
    return 0 if overall else 1

if __name__ == "__main__":
    try:
        exitcode = asyncio.run(main())
        sys.exit(exitcode)
    except KeyboardInterrupt:
        print("\nTest interrupted")
        sys.exit(130)
